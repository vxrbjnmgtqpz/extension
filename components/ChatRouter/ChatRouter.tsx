import React, { useEffect, useState, useRef } from "react";
import ReactMarkdown from "react-markdown";
import rehypeRaw from "rehype-raw";
import rehypeHighlight from "rehype-highlight";
import remarkGfm from "remark-gfm";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { oneDark } from "react-syntax-highlighter/dist/esm/styles/prism";
import "highlight.js/styles/github-dark.css";

const AGENT_META = {
  assistant: {
    name: "Assistant",
    color: "bg-blue-100 text-blue-800",
    emoji: "ü§ñ",
  },
  user: {
    name: "User",
    color: "bg-gray-100 text-gray-800",
    emoji: "üë§",
  },
};

type AgentKey = keyof typeof AGENT_META;

interface Message {
  timestamp: string;
  sender: "User" | "Assistant" | "System";
  message: string;
  agent?: "cursor" | "chatgpt" | "copilot";
  targetAgent?: "cursor" | "chatgpt" | "copilot"; // Target agent for user messages
}

type AgentType = "cursor" | "all" | "chatgpt" | "copilot";

const isValidAgent = (agent: string): agent is AgentType => {
  return ["cursor", "all", "chatgpt", "copilot"].includes(agent);
};

interface ChatRouterProps {
  activeAgent: AgentType;
  messages?: Message[];
}

const formatTime = (iso: string) =>
  new Date(iso).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });

const getAgentMeta = (sender: string) => {
  if (sender === "Assistant") return AGENT_META.assistant;
  if (sender === "User") return AGENT_META.user;
  return AGENT_META.assistant;
};

// Function to fetch all agent logs for "all" view
const fetchAllAgentLogs = async (): Promise<Message[]> => {
  try {
    // ‚ö†Ô∏è CRITICAL: DO NOT fetch userProxy messages here - they are already included in agent relay files
    // Fetching both would cause message duplication in the "All" tab
    // User messages are written to agent relay files via /write-user-only endpoint

    // Fetch messages from all agents only
    const [cursorMsgs, chatGPTMsgs, copilotMsgs] = await Promise.all([
      fetchCursorRelayMessages(),
      fetchChatGPTRelayMessages(),
      fetchCopilotRelayMessages(),
    ]);

    // Add agent property and combine all messages
    const allMessages = [
      ...cursorMsgs.map((msg) => ({ ...msg, agent: "cursor" as const })),
      ...chatGPTMsgs.map((msg) => ({ ...msg, agent: "chatgpt" as const })),
      ...copilotMsgs.map((msg) => ({ ...msg, agent: "copilot" as const })),
      // DO NOT ADD userMsgs here - causes duplication!
    ];
    return allMessages.sort(
      (a, b) =>
        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
    );
  } catch (error) {
    console.error("Error fetching all agent logs:", error);
    return [];
  }
};

// Filter out SpecStory watermarks - but not for relay view
const filterMessages = (
  messages: Message[],
  isForRelay: boolean = false
): Message[] => {
  if (isForRelay) return messages;
  return messages.filter(
    (msg) =>
      !msg.message.startsWith("<!-- Generated by SpecStory -->") &&
      msg.sender.trim() !== "" &&
      msg.message.trim() !== ""
  );
};

const fetchCursorRelayMessages = async (): Promise<Message[]> => {
  try {
    console.log("Fetching CursorRelay.json...");
    const response = await fetch(
      `/public/CursorRelay.json?nocache=${Date.now()}`
    );
    if (!response.ok) {
      console.error(`Failed to fetch CursorRelay.json: ${response.status}`);
      return [];
    }
    const data = await response.json();
    console.log("Cursor messages:", data.messages);
    return data.messages || [];
  } catch (error: any) {
    console.error("Error fetching CursorRelay.json:", error);
    return [];
  }
};

const fetchChatGPTRelayMessages = async (): Promise<Message[]> => {
  try {
    console.log("Fetching ChatGPTRelay.json...");
    const response = await fetch(
      `/public/ChatGPTRelay.json?nocache=${Date.now()}`
    );
    if (!response.ok) {
      console.error(`Failed to fetch ChatGPTRelay.json: ${response.status}`);
      return [];
    }
    const data = await response.json();
    console.log("ChatGPT messages:", data.messages);
    return data.messages || [];
  } catch (error: any) {
    console.error("Error fetching ChatGPTRelay.json:", error);
    return [];
  }
};

const fetchCopilotRelayMessages = async (): Promise<Message[]> => {
  try {
    console.log("Fetching CopilotRelay.json...");
    const response = await fetch(
      `/public/CopilotRelay.json?nocache=${Date.now()}`
    );
    if (!response.ok) {
      console.error(`Failed to fetch CopilotRelay.json: ${response.status}`);
      return [];
    }
    const data = await response.json();
    console.log("Copilot messages:", data.messages);
    return data.messages || [];
  } catch (error: any) {
    console.error("Error fetching CopilotRelay.json:", error);
    return [];
  }
};

const fetchUserProxyMessages = async (): Promise<Message[]> => {
  try {
    console.log("Fetching userProxy.json...");
    const response = await fetch(
      `/public/userProxy.json?nocache=${Date.now()}`
    );
    if (!response.ok) {
      console.error(`Failed to fetch userProxy.json: ${response.status}`);
      return [];
    }
    const data = await response.json();
    console.log("User messages:", data.messages);

    // Transform user messages to include target agent info
    return (data.messages || []).map((msg: any) => ({
      timestamp: msg.timestamp,
      sender: "User" as const,
      message: msg.message,
      agent: msg.toAgent as "cursor" | "chatgpt" | "copilot",
      targetAgent: msg.toAgent, // Keep original target for border coloring
    }));
  } catch (error: any) {
    console.error("Error fetching userProxy.json:", error);
    return [];
  }
};

const markdownComponents = {
  code({ inline, className, children, ...props }: any) {
    const match = /language-(\w+)/.exec(className || "");
    const language = match ? match[1] : "text";
    const isDiff = language === "diff";

    if (!inline) {
      return (
        <div className="my-2 overflow-hidden border border-[#424242] rounded-lg">
          <div className="bg-[#1E1E1E] px-3 py-1.5 text-xs font-mono text-[#808080] border-b border-[#424242] flex items-center">
            <span className="opacity-60">{language}</span>
          </div>
          <SyntaxHighlighter
            style={{
              hljs: {
                display: "block",
                overflowX: "auto",
                padding: "1em",
                background: "#1E1E1E",
                color: "#abb2bf",
              },
              "hljs-comment": { color: "#5c6370", fontStyle: "italic" },
              "hljs-quote": { color: "#5c6370", fontStyle: "italic" },
              "hljs-doctag": { color: "#c678dd" },
              "hljs-keyword": { color: "#c678dd" },
              "hljs-formula": { color: "#c678dd" },
              "hljs-section": { color: "#e06c75" },
              "hljs-name": { color: "#56b6c2" }, // Changed to cyan for HTML tags
              "hljs-selector-tag": { color: "#56b6c2" }, // HTML tags
              "hljs-deletion": { color: "#e06c75" },
              "hljs-subst": { color: "#e06c75" },
              "hljs-literal": { color: "#56b6c2" },
              "hljs-string": { color: "#98c379" },
              "hljs-regexp": { color: "#98c379" },
              "hljs-addition": { color: "#98c379" },
              "hljs-attribute": { color: "#d19a66" }, // HTML attributes
              "hljs-attr": { color: "#d19a66" }, // HTML attributes
              "hljs-variable": { color: "#d19a66" },
              "hljs-template-variable": { color: "#d19a66" },
              "hljs-type": { color: "#e5c07b" },
              "hljs-selector-class": { color: "#e5c07b" },
              "hljs-selector-attr": { color: "#e5c07b" },
              "hljs-selector-pseudo": { color: "#e5c07b" },
              "hljs-number": { color: "#d19a66" },
              "hljs-symbol": { color: "#61afef" },
              "hljs-bullet": { color: "#61afef" },
              "hljs-link": { color: "#61afef", textDecoration: "underline" },
              "hljs-meta": { color: "#61afef" },
              "hljs-selector-id": { color: "#61afef" },
              "hljs-title": { color: "#61afef" },
              "hljs-built_in": { color: "#e5c07b" },
              "hljs-class .hljs-title": { color: "#e5c07b" },
              "hljs-function .hljs-title": { color: "#61afef" },
              "hljs-function .hljs-params": { color: "#abb2bf" },
              "hljs-emphasis": { fontStyle: "italic" },
              "hljs-strong": { fontWeight: "bold" },
            }}
            language={language}
            PreTag="div"
            customStyle={{
              margin: 0,
              background: "#1E1E1E",
              padding: "12px 16px",
              fontSize: "13px",
              lineHeight: "20px",
              border: "none",
            }}
            wrapLines={isDiff}
            lineProps={(line) => {
              if (!isDiff) return {};
              const content = String(line);
              if (content.startsWith("+")) {
                return {
                  style: {
                    backgroundColor: "rgba(35, 134, 54, 0.2)",
                    display: "block",
                    width: "100%",
                  },
                };
              }
              if (content.startsWith("-")) {
                return {
                  style: {
                    backgroundColor: "rgba(229, 83, 75, 0.2)",
                    display: "block",
                    width: "100%",
                  },
                };
              }
              return {};
            }}
          >
            {String(children).replace(/\n$/, "")}
          </SyntaxHighlighter>
        </div>
      );
    }

    return (
      <code
        className="bg-[#1E1E1E] px-[5px] py-[2px] rounded-[4px] text-[13px] font-mono text-[#D4D4D4]"
        {...props}
      >
        {children}
      </code>
    );
  },
};

const AGENT_LABELS = {
  all: { emoji: "üìù", label: "All" },
  chatgpt: { emoji: "üß†", label: "ChatGPT" },
  cursor: { emoji: "ü§ñ", label: "Cursor" },
  copilot: { emoji: "üõ†Ô∏è", label: "Copilot" },
};

const BASE_FORWARD_OPTIONS = {
  cursor: { emoji: "ü§ñ", label: "Cursor" },
  chatgpt: { emoji: "üß†", label: "ChatGPT" },
  copilot: { emoji: "üõ†Ô∏è", label: "Copilot" },
};

// Add color themes for each agent type
const AGENT_THEMES = {
  cursor: {
    bubble: "#2A4C47",
    bubbleText: "#E2E8F0",
    tab: "#1E4A3E",
    tabSelected: "#2D5A4E",
  },
  chatgpt: {
    bubble: "#382952", // Changed to Copilot's dark purple
    bubbleText: "#E9D8FD",
    tab: "#382952",
    tabSelected: "#4C3670",
  },
  copilot: {
    bubble: "#2D3748", // Changed to ChatGPT's grey
    bubbleText: "#CBD5E1",
    tab: "#2D3748",
    tabSelected: "#4A5568",
  },
  all: {
    bubble: "#1E293B",
    bubbleText: "#CBD5E1",
    tab: "#1E293B",
    tabSelected: "#2D3748",
  },
};

const ChatRouter: React.FC<ChatRouterProps> = ({
  activeAgent: initialAgent,
  messages,
}) => {
  const [msgs, setMsgs] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedTab, setSelectedTab] = useState<AgentType>("cursor");
  const [showForwardButtons, setShowForwardButtons] = useState(false);
  const [selectedButtons, setSelectedButtons] = useState<Set<string>>(
    new Set()
  );
  const [inputValue, setInputValue] = useState("");
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const prevMessageCountRef = useRef(0);
  const [isAtBottom, setIsAtBottom] = useState(true);
  const [showScrollButton, setShowScrollButton] = useState(false);
  const lastMessageRef = useRef<HTMLDivElement | null>(null);

  const currentAgent = isValidAgent(initialAgent) ? initialAgent : "cursor";

  const handleTabClick = (agentKey: AgentType) => {
    setSelectedTab(agentKey);
  };

  // Reset selected buttons when toggling forward buttons off
  useEffect(() => {
    if (!showForwardButtons) {
      setSelectedButtons(new Set());
    }
  }, [showForwardButtons]);

  const toggleButtonSelection = (messageId: number, buttonKey: string) => {
    const buttonId = `${messageId}-${buttonKey}`;
    setSelectedButtons((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(buttonId)) {
        newSet.delete(buttonId);
      } else {
        newSet.add(buttonId);
      }
      return newSet;
    });
  };

  // Handle scroll events to show/hide scroll button
  const handleScroll = () => {
    if (scrollContainerRef.current) {
      const { scrollTop, scrollHeight, clientHeight } =
        scrollContainerRef.current;
      const atBottom = Math.abs(scrollHeight - scrollTop - clientHeight) < 20;
      setIsAtBottom(atBottom);
      setShowScrollButton(!atBottom);
    }
  };

  // Scroll to bottom function
  const scrollToBottom = (behavior: ScrollBehavior = "auto") => {
    if (scrollContainerRef.current) {
      const container = scrollContainerRef.current;
      container.scrollTo({
        top: container.scrollHeight,
        behavior,
      });
    }
  };

  // Auto-resize textarea handler
  const adjustTextareaHeight = () => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "24px"; // Reset height to single line
      const scrollHeight = textarea.scrollHeight;
      textarea.style.height = Math.min(scrollHeight, 150) + "px"; // Max height of 150px
    }
  };

  // Handle input change
  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInputValue(e.target.value);
    adjustTextareaHeight();
  };

  // Load messages function
  // ‚ö†Ô∏è IMPORTANT NOTE FOR FUTURE AI DEVELOPERS:
  // DO NOT ADD USER MESSAGES TO INDIVIDUAL AGENT TABS - IT CAUSES MESSAGE DUPLICATION
  // User messages with colored borders should ONLY appear in the "All" tab
  // Individual agent tabs (cursor, chatgpt, copilot) should ONLY show agent responses
  const loadMessages = async () => {
    const wasAtBottom = isAtBottom;
    try {
      let newMessages: Message[] = [];
      if (selectedTab === "cursor") {
        // ONLY fetch agent messages - NO user messages to prevent duplication
        newMessages = await fetchCursorRelayMessages();
        const filteredMessages = filterMessages(newMessages, true);
        if (
          filteredMessages.length > prevMessageCountRef.current &&
          wasAtBottom
        ) {
          setTimeout(() => scrollToBottom("smooth"), 50);
        }
        // Sort by timestamp
        const sortedMessages = filteredMessages.sort(
          (a, b) =>
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );
        setMsgs(sortedMessages);
        prevMessageCountRef.current = sortedMessages.length;
      } else if (selectedTab === "chatgpt") {
        // ONLY fetch agent messages - NO user messages to prevent duplication
        newMessages = await fetchChatGPTRelayMessages();
        const filteredMessages = filterMessages(newMessages, true);
        if (
          filteredMessages.length > prevMessageCountRef.current &&
          wasAtBottom
        ) {
          setTimeout(() => scrollToBottom("smooth"), 50);
        }
        // Sort by timestamp
        const sortedMessages = filteredMessages.sort(
          (a, b) =>
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );
        setMsgs(sortedMessages);
        prevMessageCountRef.current = sortedMessages.length;
      } else if (selectedTab === "copilot") {
        // ONLY fetch agent messages - NO user messages to prevent duplication
        newMessages = await fetchCopilotRelayMessages();
        const filteredMessages = filterMessages(newMessages, true);
        if (
          filteredMessages.length > prevMessageCountRef.current &&
          wasAtBottom
        ) {
          setTimeout(() => scrollToBottom("smooth"), 50);
        }
        // Sort by timestamp
        const sortedMessages = filteredMessages.sort(
          (a, b) =>
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );
        setMsgs(sortedMessages);
        prevMessageCountRef.current = sortedMessages.length;
      } else if (selectedTab === "all") {
        // ONLY the "All" tab gets user messages with colored borders
        newMessages = await fetchAllAgentLogs();
        setMsgs(filterMessages(newMessages));
      }
      console.log(
        `Loaded ${newMessages.length} messages for ${selectedTab}:`,
        newMessages
      );
    } catch (error) {
      console.error("Error loading messages:", error);
    } finally {
      setIsLoading(false);
    }
  };

  // WebSocket setup
  useEffect(() => {
    // Load initial messages
    loadMessages();

    // Set up polling for message updates every 2 seconds
    const interval = setInterval(() => {
      loadMessages();
    }, 2000);

    return () => {
      clearInterval(interval);
    };
  }, [selectedTab]);

  // Scroll to bottom when component mounts or agent changes
  useEffect(() => {
    // Double requestAnimationFrame to ensure DOM is fully rendered
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        scrollToBottom("auto"); // Use 'auto' for instant scroll
      });
    });
    prevMessageCountRef.current = 0;
  }, [selectedTab]);

  // This effect might be redundant now with the improved loadMessages logic
  // but keeping it as a fallback for now, or for direct msgs prop updates.
  useEffect(() => {
    if (isAtBottom) {
      // Only force scroll if already at bottom
      setTimeout(() => scrollToBottom("smooth"), 50);
    }
  }, [msgs, isAtBottom]);

  // Scroll to last message when agent changes or messages update
  useEffect(() => {
    if (lastMessageRef.current) {
      lastMessageRef.current.scrollIntoView({ behavior: "auto" });
    }
  }, [selectedTab, msgs]);

  // Get forward options excluding the current tab
  const getForwardOptions = (currentTab: AgentType) => {
    const options = { ...BASE_FORWARD_OPTIONS };
    delete options[currentTab];
    return options;
  };

  const handleForward = (messageId: number, targetAgent: string) => {
    console.log(`Forwarding message ${messageId} to ${targetAgent}`);
    // TODO: Implement actual forwarding logic
  };

  // Send message handler
  const sendMessage = async () => {
    // Check if we're in forwarding mode (FWD button is active)
    if (showForwardButtons) {
      // Handle forwarding mode ONLY - don't send as regular message
      await handleForwardingMode();
    } else {
      // Normal send mode - ignore any selected buttons, just send regular message
      if (inputValue.trim()) {
        // Normal message sending
        await handleNormalSend();
      }
    }
  };

  const handleNormalSend = async () => {
    try {
      const newMessage = {
        timestamp: new Date().toISOString(),
        sender: "User",
        message: inputValue.trim(),
      };

      // Write to userProxy and agent relay files but NOT FWD files
      const response = await fetch("http://localhost:3001/write-user-only", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          agent: selectedTab,
          message: newMessage,
        }),
      });

      if (!response.ok) {
        throw new Error(`Failed to write message: ${response.status}`);
      }

      console.log("Message sent successfully:", newMessage);
      setInputValue("");
      adjustTextareaHeight();
    } catch (error) {
      console.error("Error writing to file:", error);
    }
  };

  const handleForwardingMode = async () => {
    try {
      // Check for selected messages FIRST (this is the primary use case)
      if (selectedButtons.size > 0) {
        console.log("Forwarding selected messages:", selectedButtons);

        // Parse target agents from selected buttons
        const targetAgents = Array.from(selectedButtons).map((buttonId) => {
          const [, targetAgent] = buttonId.split("-");
          return targetAgent;
        });

        // Get unique target agents
        const uniqueTargets = [...new Set(targetAgents)];

        // For now, forward to each unique target agent
        for (const targetAgent of uniqueTargets) {
          // Don't allow forwarding to "all" tab
          if (targetAgent === "all") {
            console.error("Cannot forward to 'all' tab");
            continue;
          }

          // Get messages for this specific target agent
          const messagesForTarget = Array.from(selectedButtons)
            .filter((buttonId) => buttonId.endsWith(`-${targetAgent}`))
            .map((buttonId) => {
              const [messageIdStr] = buttonId.split("-");
              const messageIndex = parseInt(messageIdStr, 10);
              return msgs[messageIndex];
            })
            .filter((msg) => msg); // Filter out any undefined messages

          if (messagesForTarget.length === 0) {
            console.error(`No valid messages found for target: ${targetAgent}`);
            continue;
          }

          // Combine all selected messages for this target into one forwarded message
          const combinedMessage = messagesForTarget
            .map((msg) => {
              // Just use the raw message content without adding extra formatting
              // since messages may already be formatted from previous forwards
              return msg.message;
            })
            .join("\n\n---\n\n");

          // Determine the sender for the From field
          let fromSender = "User"; // Default for manual forwards
          if (messagesForTarget.length === 1) {
            // Single message - use original sender
            const originalSender = messagesForTarget[0].sender;
            if (originalSender === "Assistant") {
              // Map Assistant to the current tab's agent (where the message came from)
              const agentNames = {
                cursor: "Cursor",
                chatgpt: "ChatGPT",
                copilot: "Copilot",
              };
              fromSender = agentNames[selectedTab] || "Assistant";
            } else {
              fromSender = originalSender;
            }
          } else if (messagesForTarget.length > 1) {
            // Multiple messages - check if all from same sender
            const senders = [
              ...new Set(messagesForTarget.map((msg) => msg.sender)),
            ];
            if (senders.length === 1) {
              const originalSender = senders[0];
              if (originalSender === "Assistant") {
                const agentNames = {
                  cursor: "Cursor",
                  chatgpt: "ChatGPT",
                  copilot: "Copilot",
                };
                fromSender = agentNames[selectedTab] || "Assistant";
              } else {
                fromSender = originalSender;
              }
            } else {
              fromSender = "User"; // Mixed senders, default to User
            }
          }

          const forwardedMessage = {
            timestamp: new Date().toISOString(),
            From: fromSender,
            message: combinedMessage,
            toAgent: targetAgent,
          };

          console.log(
            `Forwarding combined message to ${targetAgent}:`,
            forwardedMessage
          );

          // Send to FWD-only endpoint to avoid adding to user messages
          const response = await fetch("http://localhost:3001/write-fwd-only", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              agent: targetAgent,
              message: forwardedMessage,
            }),
          });

          if (!response.ok) {
            throw new Error(
              `Failed to forward message to ${targetAgent}: ${response.status}`
            );
          }

          console.log(
            "Selected messages forwarded successfully to",
            targetAgent
          );
        }

        // Clear selections after successful forward
        setSelectedButtons(new Set());

        // Turn off FWD mode after successful forward
        setShowForwardButtons(false);
      } else if (inputValue.trim()) {
        // Fallback: If no messages selected but there's input text, forward to selectedTab
        const targetAgent = selectedTab;

        // Don't allow forwarding to "all" tab
        if (targetAgent === "all") {
          console.error("Cannot forward to 'all' tab");
          return;
        }

        const forwardedMessage = {
          timestamp: new Date().toISOString(),
          From: "User",
          message: inputValue.trim(),
          toAgent: targetAgent,
        };

        console.log("Forwarding input message:", forwardedMessage);

        const response = await fetch("http://localhost:3001/write-fwd-only", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            agent: targetAgent,
            message: forwardedMessage,
          }),
        });

        if (!response.ok) {
          throw new Error(`Failed to forward message: ${response.status}`);
        }

        console.log("Input message forwarded successfully to", targetAgent);

        // Clear input after successful forward
        setInputValue("");
        adjustTextareaHeight();

        // Turn off FWD mode after successful forward
        setShowForwardButtons(false);
      } else {
        console.error("No messages selected and no input text to forward");
        return;
      }
    } catch (error) {
      console.error("Error forwarding message:", error);
    }
  };

  // Helper function to get agent display name
  const getAgentDisplayName = (agent: string) => {
    const agentNames = {
      chatgpt: "ChatGPT",
      cursor: "Cursor",
      copilot: "Copilot",
      user: "User",
    };
    return agentNames[agent as keyof typeof agentNames] || agent;
  };

  // Update the key press handler
  const handleKeyPress = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  if (isLoading) {
    return (
      <div className="h-full w-full flex items-center justify-center bg-[#1e1e1e]">
        <div className="text-[#cccccc]">Loading messages...</div>
      </div>
    );
  }

  return (
    <>
      {/* Chat History Container */}
      <div
        ref={scrollContainerRef}
        onScroll={handleScroll}
        style={{
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          bottom: "110px",
          overflowY: "auto",
          overflowX: "hidden",
          background: "#1E1E1E",
          zIndex: 1,
          paddingBottom: "20px", // Add padding to prevent message cutoff
        }}
      >
        {msgs.map((line, idx) => (
          <div
            key={idx}
            style={{
              width: "100%",
              padding: "20px 0px", // Reduced from 40px to 20px
              display: "flex",
              justifyContent:
                line.sender === "User" ? "flex-end" : "flex-start",
              position: "relative",
              alignItems: "flex-start",
            }}
          >
            {/* Message content */}
            <div
              style={{
                display: "flex",
                flexDirection: "column",
                gap: "2px",
                maxWidth: line.sender === "User" ? "100%" : "100%", // User messages 100%, agent messages 80%
                marginRight: line.sender === "User" ? "0" : "20px", // Reduced from 100px to 20px
                marginLeft: line.sender === "User" ? "20px" : "0", // Reduced from 100px to 20px
              }}
            >
              {/* Timestamp */}
              <div
                style={{
                  fontSize: "8px",
                  color: "#666",
                  marginBottom: "2px",
                }}
              >
                {formatTime(line.timestamp)}
              </div>

              {/* Agent nametag for All tab */}
              {selectedTab === "all" && line.sender === "Assistant" && (
                <div
                  style={{
                    fontSize: "8px",
                    fontWeight: "bold",
                    marginBottom: "4px",
                    color:
                      line.agent === "cursor"
                        ? AGENT_THEMES.cursor.bubbleText
                        : line.agent === "chatgpt"
                        ? AGENT_THEMES.chatgpt.bubbleText
                        : line.agent === "copilot"
                        ? AGENT_THEMES.copilot.bubbleText
                        : AGENT_THEMES[selectedTab].bubbleText,
                    opacity: 0.9,
                    display: "flex",
                    alignItems: "center",
                    gap: "4px",
                  }}
                >
                  <span>
                    {line.agent === "cursor"
                      ? "ü§ñ"
                      : line.agent === "chatgpt"
                      ? "üß†"
                      : line.agent === "copilot"
                      ? "üõ†Ô∏è"
                      : "ü§ñ"}
                  </span>
                  <span>
                    {line.agent === "cursor"
                      ? "Cursor"
                      : line.agent === "chatgpt"
                      ? "ChatGPT"
                      : line.agent === "copilot"
                      ? "Copilot"
                      : "Assistant"}
                  </span>
                </div>
              )}

              <div
                style={{
                  backgroundColor:
                    line.sender === "User"
                      ? "#1E3B54"
                      : selectedTab === "all"
                      ? line.agent === "cursor"
                        ? AGENT_THEMES.cursor.bubble
                        : line.agent === "chatgpt"
                        ? AGENT_THEMES.chatgpt.bubble
                        : line.agent === "copilot"
                        ? AGENT_THEMES.copilot.bubble
                        : AGENT_THEMES[selectedTab].bubble
                      : AGENT_THEMES[selectedTab].bubble,
                  borderRadius: "12px",
                  padding: "8px 12px",
                  fontSize: "10px",
                  lineHeight: "1.4",
                  wordBreak: "break-word",
                  color:
                    line.sender === "User"
                      ? "#E2E8F0"
                      : selectedTab === "all"
                      ? line.agent === "cursor"
                        ? AGENT_THEMES.cursor.bubbleText
                        : line.agent === "chatgpt"
                        ? AGENT_THEMES.chatgpt.bubbleText
                        : line.agent === "copilot"
                        ? AGENT_THEMES.copilot.bubbleText
                        : AGENT_THEMES[selectedTab].bubbleText
                      : AGENT_THEMES[selectedTab].bubbleText,
                  // Add colored border for user messages based on target agent - ONLY in ALL tab
                  border:
                    selectedTab === "all" && line.sender === "User"
                      ? (() => {
                          // Use targetAgent if available, otherwise use agent field, otherwise default to cursor
                          const agentForBorder =
                            line.targetAgent || line.agent || "cursor";
                          console.log("FORCING BORDER:", {
                            selectedTab,
                            sender: line.sender,
                            targetAgent: line.targetAgent,
                            agent: line.agent,
                            agentForBorder,
                            message: line.message.substring(0, 50),
                          });
                          return `4px solid ${AGENT_THEMES[agentForBorder].tabSelected}`;
                        })()
                      : "none",
                  boxShadow:
                    selectedTab === "all" && line.sender === "User"
                      ? (() => {
                          const agentForBorder =
                            line.targetAgent || line.agent || "cursor";
                          return `0 0 15px ${AGENT_THEMES[agentForBorder].tabSelected}80, inset 0 0 0 2px ${AGENT_THEMES[agentForBorder].tabSelected}60`;
                        })()
                      : "none",
                }}
              >
                <ReactMarkdown
                  rehypePlugins={[rehypeRaw, rehypeHighlight]}
                  remarkPlugins={[remarkGfm]}
                  components={markdownComponents}
                >
                  {line.message}
                </ReactMarkdown>
              </div>
            </div>

            {/* FWD buttons for ALL chat bubbles, always on the right side of the bubble */}
            {showForwardButtons && (
              <div
                style={{
                  position: "absolute",
                  right: "8px",
                  left: "auto",
                  top: "50%",
                  transform: "translateY(-50%)",
                  display: "flex",
                  flexDirection: "column",
                  gap: "4px",
                }}
              >
                {Object.entries(getForwardOptions(selectedTab)).map(
                  ([key, { emoji }]) => {
                    const buttonId = `${idx}-${key}`;
                    const isSelected = selectedButtons.has(buttonId);
                    return (
                      <button
                        key={key}
                        onClick={() => toggleButtonSelection(idx, key)}
                        style={{
                          display: "flex",
                          alignItems: "center",
                          padding: "2px 4px",
                          fontSize: "12px",
                          background: isSelected ? "#2D6F47" : "#193C47",
                          border: `1px solid ${
                            isSelected ? "#4CAF50" : "#2D4A5E"
                          }`,
                          borderRadius: "4px",
                          color: isSelected ? "#98FB98" : "#E2E8F0",
                          cursor: "pointer",
                          minWidth: "40px",
                          justifyContent: "center",
                          transition: "all 0.2s ease-in-out",
                        }}
                      >
                        ‚û°Ô∏è{emoji}
                      </button>
                    );
                  }
                )}
              </div>
            )}
          </div>
        ))}
      </div>

      {/* Floating scroll button - positioned within chat history pane */}
      {showScrollButton && (
        <button
          onClick={() => scrollToBottom("smooth")}
          style={{
            position: "fixed",
            bottom: "130px", // Changed from 120px to stay above input section
            right: "20px",
            backgroundColor: "#193C47",
            color: "#E2E8F0",
            width: "32px",
            height: "32px",
            borderRadius: "16px",
            border: "1px solid #2D4A5E",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "pointer",
            zIndex: 3,
            fontSize: "18px",
          }}
        >
          ‚¨áÔ∏è
        </button>
      )}

      {/* Input Section */}
      <div
        style={{
          position: "fixed",
          bottom: 0,
          left: 0,
          right: 0,
          minHeight: "110px", // Minimum height to accommodate single line + padding
          background: "#1E1E1E",
          borderTop: "1px solid #2D4A5E",
          zIndex: 2,
          display: "flex",
          flexDirection: "column",
          padding: "10px",
        }}
      >
        {/* Input Row */}
        <div
          style={{
            display: "flex",
            gap: "10px",
            marginBottom: "10px",
            flex: 1,
            alignItems: "flex-start", // Changed from center to flex-start
          }}
        >
          <textarea
            ref={textareaRef}
            value={inputValue}
            onChange={handleInputChange}
            onKeyDown={handleKeyPress}
            placeholder="Type a message to Cursor..."
            style={{
              flex: 1,
              padding: "8px 12px",
              backgroundColor: "#193C47",
              border: "1px solid #2D4A5E",
              borderRadius: "4px",
              color: "#E2E8F0",
              fontSize: "12px",
              resize: "none",
              minHeight: "24px", // Single line height
              maxHeight: "150px",
              overflow: "hidden",
            }}
          />
          <div
            style={{
              display: "flex",
              flexDirection: "column",
              gap: "4px",
            }}
          >
            <button
              onClick={sendMessage}
              style={{
                padding: "8px 16px",
                backgroundColor: "#193C47",
                border: "1px solid #2D4A5E",
                borderRadius: "4px",
                color: "#E2E8F0",
                fontSize: "12px",
                cursor: "pointer",
              }}
            >
              Send
            </button>
            <button
              onClick={() => setShowForwardButtons(!showForwardButtons)}
              style={{
                padding: "4px 8px",
                backgroundColor: showForwardButtons ? "#2D4A5E" : "#193C47",
                border: "1px solid #2D4A5E",
                borderRadius: "4px",
                color: "#E2E8F0",
                fontSize: "10px",
                cursor: "pointer",
                opacity: showForwardButtons ? 1 : 0.7,
              }}
            >
              FWD
            </button>
          </div>
        </div>

        {/* Tabs Row */}
        <div
          style={{
            display: "flex",
            gap: "10px",
            justifyContent: "center",
          }}
        >
          {Object.entries(AGENT_LABELS).map(([key, { emoji, label }]) => (
            <button
              key={key}
              onClick={() => handleTabClick(key as AgentType)}
              style={{
                padding: "4px 12px",
                borderRadius: "4px",
                fontSize: "12px",
                backgroundColor:
                  selectedTab === key
                    ? AGENT_THEMES[key as AgentType].tabSelected
                    : AGENT_THEMES[key as AgentType].tab,
                color: "#E2E8F0",
                border: `1px solid ${
                  AGENT_THEMES[key as AgentType].tabSelected
                }`,
                opacity: selectedTab === key ? 1 : 0.7,
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                gap: "4px",
              }}
            >
              <span>{emoji}</span>
              <span>{label}</span>
            </button>
          ))}
        </div>
      </div>
    </>
  );
};

export default ChatRouter;
