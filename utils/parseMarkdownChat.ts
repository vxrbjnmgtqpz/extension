export function parseMarkdownChat(md: string) {
  const lines = md.split('\n');
  const messages: { sender: string; message: string; timestamp: string }[] = [];
  let currentSender = '';
  let currentMessage: string[] = [];
  let isInCodeBlock = false;

  for (const line of lines) {
    // Skip empty lines and SpecStory header
    if (line.trim() === '' || line.includes('Generated by SpecStory')) continue;

    // Handle code blocks
    if (line.startsWith('```')) {
      isInCodeBlock = !isInCodeBlock;
      if (currentSender) currentMessage.push(line);
      continue;
    }

    // If in code block, add line as-is
    if (isInCodeBlock) {
      if (currentSender) currentMessage.push(line);
      continue;
    }

    // Check for new message
    if (line.startsWith('## ')) {
      // Save previous message if exists
      if (currentSender && currentMessage.length > 0) {
        messages.push({
          sender: currentSender,
          message: currentMessage.join('\n').trim(),
          timestamp: new Date().toISOString()
        });
        currentMessage = [];
      }
      // Set new sender
      currentSender = line.replace('## ', '').trim();
    } else if (currentSender) {
      // Clean up formatting but preserve emojis
      let cleanLine = line
        .replace(/^[#]+\s+/, '')  // Remove markdown headers
        .replace(/^\s*[-*]\s+/, '')  // Remove list markers
        .trim();

      if (cleanLine) {
        currentMessage.push(cleanLine);
      }
    }
  }

  // Add final message
  if (currentSender && currentMessage.length > 0) {
    messages.push({
      sender: currentSender,
      message: currentMessage.join('\n').trim(),
      timestamp: new Date().toISOString()
    });
  }

  return messages;
} 